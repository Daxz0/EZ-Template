"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3585],{9679:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var s=t(5893),a=t(1151);const o={title:"Tuning Constants",description:"Tuning the PID system to accurately rotate the desired amount"},r=void 0,i={id:"tutorials/tuning_constants",title:"Tuning Constants",description:"Tuning the PID system to accurately rotate the desired amount",source:"@site/ez-template-docs/tutorials/tuning_constants.md",sourceDirName:"tutorials",slug:"/tutorials/tuning_constants",permalink:"/EZ-Template/tutorials/tuning_constants",draft:!1,unlisted:!1,editUrl:"https://github.com/EZ-Robotics/EZ-Template/tree/website/${versionDocsDirPath}/${docPath}/ez-template-docs/tutorials/tuning_constants.md",tags:[],version:"current",frontMatter:{title:"Tuning Constants",description:"Tuning the PID system to accurately rotate the desired amount"},sidebar:"docs",previous:{title:"Example Autonomous Routines",permalink:"/EZ-Template/tutorials/example_autons"},next:{title:"Joystick Curves",permalink:"/EZ-Template/tutorials/joystick_curve"}},l={},c=[{value:"Setup",id:"setup",level:2},{value:"Uncommenting Default Constants",id:"uncommenting-default-constants",level:3},{value:"Running the Autonomous",id:"running-the-autonomous",level:3},{value:"Modifying Constants",id:"modifying-constants",level:3},{value:"Different Constants",id:"different-constants",level:3},{value:"Using the PID Tuner",id:"using-the-pid-tuner",level:3},{value:"Tuning PID",id:"tuning-pid",level:2},{value:"Step 1 - kP",id:"step-1---kp",level:3},{value:"Step 2 - kD",id:"step-2---kd",level:3},{value:"Step 3 - Repeat",id:"step-3---repeat",level:3},{value:"Step 4 - kI",id:"step-4---ki",level:3},{value:"Tuning Forward/Backward Constants",id:"tuning-forwardbackward-constants",level:2},{value:"Step 1 - Forward/Backwards Constants",id:"step-1---forwardbackwards-constants",level:3},{value:"Step 2 - Heading Correction",id:"step-2---heading-correction",level:3},{value:"Step 3 - Slew",id:"step-3---slew",level:3},{value:"Tuning Turns",id:"tuning-turns",level:2},{value:"Step 1 - Constants",id:"step-1---constants",level:3},{value:"Step 2 - kI",id:"step-2---ki",level:3},{value:"Step 3 - Slew",id:"step-3---slew-1",level:3},{value:"Swings",id:"swings",level:2},{value:"Forwards and Backwards PID Constants",id:"forwards-and-backwards-pid-constants",level:3},{value:"Slew with Angle as Target",id:"slew-with-angle-as-target",level:3},{value:"Slew with Length as Target",id:"slew-with-length-as-target",level:3},{value:"General Tips",id:"general-tips",level:2},{value:"Find Your Maximum",id:"find-your-maximum",level:3},{value:"Change it Up",id:"change-it-up",level:3}];function d(e){const n={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["For more information on how PID controllers work, ",(0,s.jsx)(n.a,{href:"http://georgegillard.com/documents/2-introduction-to-pid-controllers",children:"reference this document made by George Gillard"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,s.jsx)(n.h3,{id:"uncommenting-default-constants",children:"Uncommenting Default Constants"}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.code,{children:"src/main.cpp"}),", make sure ",(0,s.jsx)(n.code,{children:"default_constants()"})," is uncommented in ",(0,s.jsx)(n.code,{children:"void initialize()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void initialize() {\r\n    . . .\r\n    default_constants();\r\n    . . .\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"running-the-autonomous",children:"Running the Autonomous"}),"\n",(0,s.jsxs)(n.p,{children:["You can run one of the example autonomous routines to tune your constants.  When you're tuning drive constants, run ",(0,s.jsx)(n.code,{children:"drive_example()"}),".  When you're tuning turn constants, run ",(0,s.jsx)(n.code,{children:"turn_example()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Look at our ",(0,s.jsx)(n.a,{href:"https://ez-robotics.github.io/EZ-Template/tutorials/using_auton_selector",children:"Using Auton Selector tutorial"})," for how to select autonomous routines!"]}),"\n",(0,s.jsx)(n.h3,{id:"modifying-constants",children:"Modifying Constants"}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.code,{children:"src/autons.cpp"}),", there is a function called ",(0,s.jsx)(n.code,{children:"default_constants()"}),".  This function is where all of your modified PID constants can be set."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void default_constants() {\r\n  // PID Constants\r\n  chassis.pid_drive_constants_set(10, 0, 100); // Sets forward and backward\r\n  chassis.pid_heading_constants_set(3, 0, 20);\r\n  chassis.pid_turn_constants_set(3, 0, 20);\r\n  chassis.pid_swing_constants_set(5, 0, 30); // Sets forward and backward\r\n\r\n  // Swing Constants\r\n  chassis.slew_drive_constants_set(7_in, 80); // Sets forward and backward\r\n  chassis.slew_turn_constants_set(5_deg, 50);\r\n  chassis.slew_swing_constants_set(5_deg, 50); // Sets forward and backward\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"different-constants",children:"Different Constants"}),"\n",(0,s.jsx)(n.p,{children:"When your robot has huge weight shifts (grabbing a mobile goal, raising a lift, etc), you might want to have different constants for those states.  You can have multiple functions with constants for different states and change constants during your autonomous routine."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void grab_mogo() {\r\n  chassis.pid_drive_set(40_in, 110, true);\r\n  chassis.pid_wait();\r\n\r\n  one_mogo_constants();\r\n  chassis.pid_drive_set(-40_in, 110, true);\r\n  chassis.pid_wait();\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-the-pid-tuner",children:"Using the PID Tuner"}),"\n",(0,s.jsx)(n.p,{children:"EZ-Template's PID Tuner allows users to tune PID faster.  The alternative to using this is to reupload your code every time you want to try new constants."}),"\n",(0,s.jsxs)(n.p,{children:["To enable it, we can use ",(0,s.jsx)(n.code,{children:"chassis.pid_tuner_toggle();"}),".  In the code below it is only allowed to run when we're not connected to a competition switch or tournament.  This is done to avoid accidentally leaving this code in your code while at a competition and running your autonomous during the driver controlled period."]}),"\n",(0,s.jsx)(n.p,{children:"Once the PID Tuner is enabled we can navigate the menus on the brain screen with the arrow keys on the controller.  To increase or decrease the constant we can use A and Y on the controller."}),"\n",(0,s.jsx)(n.p,{children:"To select your autonomous routine, navigate the autonomous selector until you find the one you want to run.  Then once you switch to the PID Tuner, the last auton page you were on will run when you press B on your controller."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void opcontrol() {\r\n  // This is preference to what you like to drive on\r\n  chassis.drive_brake_set(MOTOR_BRAKE_COAST);\r\n  \r\n  while (true) {\r\n    \r\n    // PID Tuner\r\n    // After you find values that you're happy with, you'll have to set them in auton.cpp\r\n    if (!pros::competition::is_connected()) { \r\n      // Enable / Disable PID Tuner\r\n      if (master.get_digital_new_press(DIGITAL_X)) \r\n        chassis.pid_tuner_toggle();\r\n        \r\n      // Trigger the selected autonomous routine\r\n      if (master.get_digital_new_press(DIGITAL_B)) \r\n        autonomous();\r\n\r\n      chassis.pid_tuner_iterate(); // Allow PID Tuner to iterate\r\n    } \r\n\r\n    chassis.opcontrol_tank(); // Tank control\r\n\r\n    pros::delay(ez::util::DELAY_TIME); // This is used for timer calculations!  Keep this ez::util::DELAY_TIME\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"tuning-pid",children:"Tuning PID"}),"\n",(0,s.jsx)(n.p,{children:"This video is a good visual representation of what each constant does."}),"\n",(0,s.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/qKy98Cbcltw?si=tC9FrdKh6DR1Imrp",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,s.jsx)(n.h3,{id:"step-1---kp",children:"Step 1 - kP"}),"\n",(0,s.jsx)(n.p,{children:"You'll start with kP.  Set it to some number, and run your example autonomous.  The robot will either undershoot the target (kP too low), or the robot is oscillate around the target (kP too high)."}),"\n",(0,s.jsx)(n.p,{children:"To tune a PD controller, you want the kP to oscillate a little bit, usually a bounce or two."}),"\n",(0,s.jsx)(n.h3,{id:"step-2---kd",children:"Step 2 - kD"}),"\n",(0,s.jsx)(n.p,{children:'After finding a kP that oscillates a little, we can tune kD.  Increase kD until the oscillation goes away.  This movement should look more "snappy" then just a P loop.'}),"\n",(0,s.jsx)(n.h3,{id:"step-3---repeat",children:"Step 3 - Repeat"}),"\n",(0,s.jsx)(n.p,{children:"Repeat Steps 1 and Steps 2 until kD cannot remove oscillation from the movement.  Then go back to the last values that worked."}),"\n",(0,s.jsx)(n.h3,{id:"step-4---ki",children:"Step 4 - kI"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes you need a little extra power to get your robot all the way there.  Integral can be a dangerous variable because it grows exponentially.  The fourth parameter is what the error needs to be for I to start.  For turns, we found around 15 degrees is good."}),"\n",(0,s.jsx)(n.p,{children:"Increase kI until any minor disturbances are accounted for.  You might need to adjust kD while tuning kI."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"tuning-forwardbackward-constants",children:"Tuning Forward/Backward Constants"}),"\n",(0,s.jsx)(n.h3,{id:"step-1---forwardbackwards-constants",children:"Step 1 - Forward/Backwards Constants"}),"\n",(0,s.jsx)(n.p,{children:"Using the steps above, modify your kP, kD, and if you chose to, kI."}),"\n",(0,s.jsx)(n.p,{children:"If you see the robot acting differently going forwards and backwards, you can have different constants for each.  This is usually only needed when something is off balance on your robot mechanically."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.pid_drive_constants_forward_set(10, 0, 100);\r\n  chassis.pid_drive_constants_backward_set(10, 0, 100);\n"})}),"\n",(0,s.jsx)(n.p,{children:"If you don't have problems with differences between forward and backwards, you can use the following instead."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.pid_drive_constants_set(10, 0, 100); // Sets forward and backward\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-2---heading-correction",children:"Step 2 - Heading Correction"}),"\n",(0,s.jsx)(n.p,{children:"Heading correction tries to keep your robot facing an angle while driving forward.  The constants for this are generally higher then other PID controllers because you're only correcting for a few degrees of error."}),"\n",(0,s.jsx)(n.p,{children:"The same steps above can be used to tune the heading constants.  Increase kP until there's a little oscillation, increase kD until it goes away, repeat."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.pid_heading_constants_set(3, 0, 20);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-3---slew",children:"Step 3 - Slew"}),"\n",(0,s.jsxs)(n.p,{children:["Slew ramps the speed of the robot up from the start of the motion to avoid wheelies and wheel slip.",(0,s.jsx)(n.br,{}),"\n","The first parameter is the distance the robot will increase from min power to the max power you set in your autonomous function.",(0,s.jsx)(n.br,{}),"\n","The second parameter is the starting power the robot will use when slewing."]}),"\n",(0,s.jsx)(n.p,{children:"Minimum power should be as high as it can be without causing the robot to wheelie or cause wheel slip.  Slew distance should be as small as it can be without causing the same."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.slew_drive_constants_set(7_in, 80); // This sets forwards and backwards constants\n"})}),"\n",(0,s.jsx)(n.p,{children:"If your robot behaves differently forward and backwards, you can set different slew rates for both."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.slew_drive_constants_forward_set(7_in, 80);\r\n  chassis.slew_drive_constants_backward_set(7_in, 80);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"tuning-turns",children:"Tuning Turns"}),"\n",(0,s.jsx)(n.h3,{id:"step-1---constants",children:"Step 1 - Constants"}),"\n",(0,s.jsx)(n.p,{children:"Using the same steps as above, set kP to some number and modify it until there is slight oscillation, one or two bounces."}),"\n",(0,s.jsx)(n.p,{children:"Increase kD until the oscillation is gone."}),"\n",(0,s.jsx)(n.p,{children:"Repeat until kD cannot fix the oscillation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.pid_turn_constants_set(3, 0, 20);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-2---ki",children:"Step 2 - kI"}),"\n",(0,s.jsx)(n.p,{children:"What about when PD isn't enough?"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes you need a little extra power to get your robot all the way there.  Integral can be a dangerous variable because it grows exponentially.  The fourth parameter is what the error needs to be for I to start.  For turns, we found around 15 degrees is good."}),"\n",(0,s.jsx)(n.p,{children:"Increase kI until any minor disturbances are accounted for.  You might need to adjust kD while tuning kI."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.pid_turn_constants_set(3, 0.003, 20, 15);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-3---slew-1",children:"Step 3 - Slew"}),"\n",(0,s.jsx)(n.p,{children:"Just like with drive motions, you can use slew with turns.  The input distance is an angle instead of a length unit, but it works in the same way."}),"\n",(0,s.jsxs)(n.p,{children:["The first parameter is the distance the robot will increase from min power to the max power you set in your autonomous function.",(0,s.jsx)(n.br,{}),"\n","The second parameter is the starting power the robot will use when slewing."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.slew_turn_constants_set(5_deg, 50);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"swings",children:"Swings"}),"\n",(0,s.jsx)(n.h3,{id:"forwards-and-backwards-pid-constants",children:"Forwards and Backwards PID Constants"}),"\n",(0,s.jsx)(n.p,{children:"Just like with driving, you can have independent forward and backward constants for your swing turns."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.pid_swing_constants_forward_set(5, 0, 30);\r\n  chassis.pid_swing_constants_forward_set(5, 0, 30);\n"})}),"\n",(0,s.jsx)(n.p,{children:"And if this isn't a problem for your robot, you can just use this function."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.pid_swing_constants_set(5, 0, 30); // Sets forward and backward\n"})}),"\n",(0,s.jsx)(n.h3,{id:"slew-with-angle-as-target",children:"Slew with Angle as Target"}),"\n",(0,s.jsx)(n.p,{children:"Swing turns are a middle ground between driving and turns.  Because of this, you have two options for how you want to use slew.  This option uses angle just like turns do."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.slew_swing_constants_set(5_deg, 50); // Sets forward and backward\n"})}),"\n",(0,s.jsx)(n.p,{children:"If your robot is different forwards and backwards, these are the functions you'd want to use."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.slew_swing_constants_forward_set(5_deg, 50);\r\n  chassis.slew_swing_constants_backward_set(5_deg, 50);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"slew-with-length-as-target",children:"Slew with Length as Target"}),"\n",(0,s.jsx)(n.p,{children:"You can use length instead of angle to accomplish the same thing with swing turns."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.slew_swing_constants_set(7_in, 50); // Sets forward and backward\n"})}),"\n",(0,s.jsx)(n.p,{children:"And, big surprise, you can have independent forward and backward control over the constants."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  chassis.slew_swing_constants_forward_set(7_in, 50);\r\n  chassis.slew_swing_constants_backward_set(5_in, 50);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"general-tips",children:"General Tips"}),"\n",(0,s.jsx)(n.h3,{id:"find-your-maximum",children:"Find Your Maximum"}),"\n",(0,s.jsx)(n.p,{children:"When you're tuning PID, don't increase kP by 0.1 every time you run.  If 1.0 isn't high enough, try 10.0.  If that's still not high enough, go to 20.0.  In this process you'll quickly find a minimum and maximum value that it can be within."}),"\n",(0,s.jsx)(n.h3,{id:"change-it-up",children:"Change it Up"}),"\n",(0,s.jsx)(n.p,{children:"Your goal is to make PID constants that generally work on all of your drive motions.  If you're tuning constants to a single motion, it's less likely to work on everything you make."}),"\n",(0,s.jsx)(n.p,{children:"Using the example autons to tune is a good start.  But once you're in the ballpark of where you want to be, start slowly making an autonomous routine and you can tune it more as you go.  Once that first autonomous routine is done, your constants will be good."})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>r});var s=t(7294);const a={},o=s.createContext(a);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);