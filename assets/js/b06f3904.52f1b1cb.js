"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[780],{6289:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>d,toc:()=>c});var r=n(5893),i=n(1151);const t={title:"Example Autonomous Routines",description:"Some examples and test routines"},a="Example Autonomous Routines",d={id:"tutorials/example_autons",title:"Example Autonomous Routines",description:"Some examples and test routines",source:"@site/ez-template-docs/tutorials/example_autons.md",sourceDirName:"tutorials",slug:"/tutorials/example_autons",permalink:"/EZ-Template/tutorials/example_autons",draft:!1,unlisted:!1,editUrl:"https://github.com/EZ-Robotics/EZ-Template/tree/main/website/ez-template-docs/tutorials/example_autons.md",tags:[],version:"current",frontMatter:{title:"Example Autonomous Routines",description:"Some examples and test routines"},sidebar:"tutorialSidebar",previous:{title:"Adding Autonomous Routines",permalink:"/EZ-Template/tutorials/autons"},next:{title:"Joystick Curves",permalink:"/EZ-Template/tutorials/joystick_curve"}},o={},c=[{value:"Assumed Constants",id:"assumed-constants",level:2},{value:"Drive",id:"drive",level:2},{value:"Turn",id:"turn",level:2},{value:"Drive and Turn",id:"drive-and-turn",level:2},{value:"Wait Until and Changing Speed",id:"wait-until-and-changing-speed",level:2},{value:"Swing Turns",id:"swing-turns",level:2},{value:"Combining All Movements",id:"combining-all-movements",level:2},{value:"Interference",id:"interference",level:2}];function l(e){const s={code:"code",h1:"h1",h2:"h2",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h1,{id:"example-autonomous-routines",children:(0,r.jsx)(s.strong,{children:"Example Autonomous Routines"})}),"\n",(0,r.jsx)(s.h2,{id:"assumed-constants",children:"Assumed Constants"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"const int DRIVE_SPEED = 110; \r\nconst int TURN_SPEED  = 90;\r\nconst int SWING_SPEED = 90;\n"})}),"\n",(0,r.jsx)(s.h2,{id:"drive",children:"Drive"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"void drive_example() {\r\n  // The first parameter is target inches\r\n  // The second parameter is max speed the robot will drive at\r\n  // The third parameter is a boolean (true or false) for enabling/disabling a slew at the start of drive motions\r\n  // for slew, only enable it when the drive distance is greater then the slew distance + a few inches\r\n\r\n\r\n  chassis.set_drive_pid(24, DRIVE_SPEED, true);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_drive_pid(-12, DRIVE_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_drive_pid(-12, DRIVE_SPEED);\r\n  chassis.wait_drive();\r\n}\n"})}),"\n",(0,r.jsx)(s.h2,{id:"turn",children:"Turn"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"void turn_example() {\r\n  // The first parameter is target degrees\r\n  // The second parameter is max speed the robot will drive at\r\n\r\n\r\n  chassis.set_turn_pid(90, TURN_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_turn_pid(45, TURN_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_turn_pid(0, TURN_SPEED);\r\n  chassis.wait_drive();\r\n}\n"})}),"\n",(0,r.jsx)(s.h2,{id:"drive-and-turn",children:"Drive and Turn"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"void drive_and_turn() {\r\n  chassis.set_drive_pid(24, DRIVE_SPEED, true);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_turn_pid(45, TURN_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_turn_pid(-45, TURN_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_turn_pid(0, TURN_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_drive_pid(-24, DRIVE_SPEED, true);\r\n  chassis.wait_drive();\r\n}\n"})}),"\n",(0,r.jsx)(s.h2,{id:"wait-until-and-changing-speed",children:"Wait Until and Changing Speed"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"void wait_until_change_speed() {\r\n  // wait_until will wait until the robot gets to a desired position\r\n\r\n\r\n  // When the robot gets to 6 inches, the robot will travel the remaining distance at a max speed of 40\r\n  chassis.set_drive_pid(24, DRIVE_SPEED, true);\r\n  chassis.wait_until(6);\r\n  chassis.set_max_speed(40); // After driving 6 inches at DRIVE_SPEED, the robot will go the remaining distance at 40 speed\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_turn_pid(45, TURN_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_turn_pid(-45, TURN_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_turn_pid(0, TURN_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  // When the robot gets to -6 inches, the robot will travel the remaining distance at a max speed of 40\r\n  chassis.set_drive_pid(-24, DRIVE_SPEED, true);\r\n  chassis.wait_until(-6);\r\n  chassis.set_max_speed(40); // After driving 6 inches at DRIVE_SPEED, the robot will go the remaining distance at 40 speed\r\n  chassis.wait_drive();\r\n}\n"})}),"\n",(0,r.jsx)(s.h2,{id:"swing-turns",children:"Swing Turns"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"void swing_example() {\r\n  // The first parameter is ez::LEFT_SWING or ez::RIGHT_SWING\r\n  // The second parameter is target degrees\r\n  // The third parameter is speed of the moving side of the drive\r\n\r\n\r\n  chassis.set_swing_pid(ez::LEFT_SWING, 45, SWING_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_drive_pid(24, DRIVE_SPEED, true);\r\n  chassis.wait_until(12);\r\n\r\n  chassis.set_swing_pid(ez::RIGHT_SWING, 0, SWING_SPEED);\r\n  chassis.wait_drive();\r\n}\n"})}),"\n",(0,r.jsx)(s.h2,{id:"combining-all-movements",children:"Combining All Movements"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"void combining_movements() {\r\n  chassis.set_drive_pid(24, DRIVE_SPEED, true);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_turn_pid(45, TURN_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_drive_pid(ez::RIGHT_SWING, -45, TURN_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_turn_pid(0, TURN_SPEED);\r\n  chassis.wait_drive();\r\n\r\n  chassis.set_drive_pid(-24, DRIVE_SPEED, true);\r\n  chassis.wait_drive();\r\n}\n"})}),"\n",(0,r.jsx)(s.h2,{id:"interference",children:"Interference"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'void tug (int attempts) {\r\n  for (int i=0; i<attempts-1; i++) {\r\n    // Attempt to drive backwards\r\n    printf("i - %i", i);\r\n    chassis.set_drive_pid(-12, 127);\r\n    chassis.wait_drive();\r\n\r\n    // If failsafed...\r\n    if (chassis.interfered) {\r\n      chassis.reset_drive_sensor();\r\n      chassis.set_drive_pid(-2, 20);\r\n      pros::delay(1000);\r\n    }\r\n    // If robot successfully drove back, return\r\n    else {\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\n// If there is no interference, robot will drive forward and turn 90 degrees. \r\n// If interfered, robot will drive forward and then attempt to drive backwards. \r\nvoid interfered_example() {\r\n chassis.set_drive_pid(24, DRIVE_SPEED, true);\r\n chassis.wait_drive();\r\n\r\n if (chassis.interfered) {\r\n   tug(3);\r\n   return;\r\n }\r\n\r\n chassis.set_turn_pid(90, TURN_SPEED);\r\n chassis.wait_drive();\r\n}\n'})})]})}function h(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},1151:(e,s,n)=>{n.d(s,{Z:()=>d,a:()=>a});var r=n(7294);const i={},t=r.createContext(i);function a(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);